package dr.evomodel.MSSD;

import dr.evolution.tree.Tree;
import dr.evomodel.tree.TreeModel;
import dr.inference.model.AbstractModelLikelihood;
import dr.inference.model.Model;
import dr.inference.model.Parameter;
import dr.inference.model.Variable;
import dr.math.GammaFunction;

public class ExponentialBranchLengthTreePrior extends AbstractModelLikelihood {

    TreeModel treeModel;

    public ExponentialBranchLengthTreePrior(TreeModel treeModel) {
        super(null);
        this.treeModel = treeModel;
    }

    protected void handleModelChangedEvent(Model model, Object object, int index) {
//AUTOGENERATED METHOD IMPLEMENTATION
    }

    protected final void handleVariableChangedEvent(Variable variable, int index, Parameter.ChangeType type) {
//AUTOGENERATED METHOD IMPLEMENTATION
    }

    protected void storeState() {
//AUTOGENERATED METHOD IMPLEMENTATION
    }

    protected void restoreState() {
//AUTOGENERATED METHOD IMPLEMENTATION
    }

    protected void acceptState() {
//AUTOGENERATED METHOD IMPLEMENTATION
    }

    public Model getModel() {
        return this;  //AUTOGENERATED METHOD IMPLEMENTATION
    }

    public double getLogLikelihood() {
        return calculateLogLikelihood();
    }

    public double calculateLogLikelihood() {
        int L = treeModel.getNodeCount();

        double totalTreeTime = Tree.Utils.getTreeLength(treeModel, treeModel.getRoot());

//        if(ctmcScale != null){ //
//            double ab=ctmcScale.getParameterValue(0);
//            return GammaFunction.lnGamma(L)-Math.log(mu*lam)-(L-1)*Math.log(totalTreeTime)-0.5*Math.log(ab)-ab*totalTreeTime;
//        }else{ // No Markov Chain for this model
        return GammaFunction.lnGamma(L) - (L - 1) * Math.log(totalTreeTime);
    }

    public void makeDirty() {
//AUTOGENERATED METHOD IMPLEMENTATION
    }
}
